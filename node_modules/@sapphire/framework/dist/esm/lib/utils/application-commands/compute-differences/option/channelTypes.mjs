import { __name } from '../../../../../chunk-G5GHKT7C.mjs';
import { ChannelType } from 'discord-api-types/v10';

var channelTypeToPrettyName = {
  [ChannelType.GuildText]: "text channel (type 0)",
  [ChannelType.GuildVoice]: "voice channel (type 2)",
  [ChannelType.GuildCategory]: "guild category (type 4)",
  [ChannelType.GuildAnnouncement]: "guild announcement channel (type 5)",
  [ChannelType.AnnouncementThread]: "guild announcement thread (type 10)",
  [ChannelType.PublicThread]: "guild public thread (type 11)",
  [ChannelType.PrivateThread]: "guild private thread (type 12)",
  [ChannelType.GuildStageVoice]: "guild stage voice channel (type 13)",
  [ChannelType.GuildDirectory]: "guild directory (type 14)",
  [ChannelType.GuildForum]: "guild forum (type 15)",
  [ChannelType.GuildMedia]: "guild media channel (type 16)"
};
var unknownChannelType = /* @__PURE__ */ __name((type) => `unknown channel type (${type}); please contact Sapphire developers about this!`, "unknownChannelType");
function getChannelTypePrettyName(type) {
  return channelTypeToPrettyName[type] ?? unknownChannelType(type);
}
__name(getChannelTypePrettyName, "getChannelTypePrettyName");
function* checkChannelTypes({
  existingChannelTypes,
  newChannelTypes,
  currentIndex,
  keyPath
}) {
  if (!existingChannelTypes?.length && newChannelTypes?.length) {
    yield {
      key: `${keyPath(currentIndex)}.channel_types`,
      original: "no channel types present",
      expected: "channel types present"
    };
  } else if (existingChannelTypes?.length && !newChannelTypes?.length) {
    yield {
      key: `${keyPath(currentIndex)}.channel_types`,
      original: "channel types present",
      expected: "no channel types present"
    };
  } else if (newChannelTypes?.length) {
    let index = 0;
    for (const channelType of newChannelTypes) {
      const currentIndex2 = index++;
      const existingChannelType = existingChannelTypes[currentIndex2];
      if (channelType !== existingChannelType) {
        yield {
          key: `${keyPath(currentIndex2)}.channel_types[${currentIndex2}]`,
          original: existingChannelType === void 0 ? "no channel type present" : getChannelTypePrettyName(existingChannelType),
          expected: getChannelTypePrettyName(channelType)
        };
      }
    }
    if (index < existingChannelTypes.length) {
      let channelType;
      while ((channelType = existingChannelTypes[index]) !== void 0) {
        yield {
          key: `${keyPath(index)}.channel_types[${index}]`,
          expected: "no channel type present",
          original: getChannelTypePrettyName(channelType)
        };
        index++;
      }
    }
  }
}
__name(checkChannelTypes, "checkChannelTypes");

export { checkChannelTypes };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=channelTypes.mjs.map